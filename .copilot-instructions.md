# Copilot Instructions for Todo Notes Tracker

## Project Overview
This is a bullet journal style todo app built with Tauri v2.8.4, featuring:
- Daily todo management with bullet journal symbols
- Date navigation (previous/next day, jump to today)
- Notes section with toggle functionality
- Pomodoro timer with custom alerts
- Text zoom accessibility features
- JSON file storage in app data directory

## Tech Stack
- **Backend**: Rust with Tauri v2.8.4, tokio async runtime
- **Frontend**: Vanilla HTML/CSS/JavaScript (no build process)
- **Storage**: JSON files in app data directory
- **Dependencies**: chrono, uuid, serde_json

## Critical Tauri Configuration

### API Access Fix
**Problem**: `window.invoke` and other Tauri APIs not available in frontend
**Solution**: Add `withGlobalTauri: true` to `tauri.conf.json`:
```json
{
  "app": {
    "withGlobalTauri": true,
    "security": {
      "csp": "default-src 'self'; script-src 'self' 'unsafe-inline'"
    }
  }
}
```

### Running the App
- **Correct**: `cd src-tauri && cargo tauri dev`
- **Wrong**: `npm run tauri dev` (no package.json needed for static frontend)

## Common Issues and Solutions

### 1. Native Dialogs Don't Work
**Problem**: `alert()`, `confirm()`, `prompt()` are blocked in Tauri webviews
**Solution**: Implement custom modal dialogs in HTML/CSS/JS

Example custom confirm dialog:
```javascript
function showConfirmDialog(message) {
    return new Promise((resolve) => {
        // Create modal HTML, handle user input, resolve promise
    });
}
```

### 2. Event Listeners Not Working
**Problem**: DOM elements not found when setting up event listeners
**Solution**: Ensure proper initialization order:
1. Wait for DOM ready
2. Initialize Tauri API
3. Declare all DOM element variables at top of file
4. Set up event listeners after DOM is ready

### 3. Zoom/Font Scaling Implementation
**Problem**: CSS custom properties not affecting all text
**Solution**: Scale at root level with rem units:
```css
:root {
    --zoom-scale: 1.0;
}
html {
    font-size: calc(16px * var(--zoom-scale));
}
/* Use rem units for scalable elements */
body { font-size: 0.875rem; }
```

**Avoid**: Fixed px units that won't scale
**Convert**: `font-size: 14px` → `font-size: 0.875rem`

### 4. File I/O and Data Persistence
**Structure**: 
- Each day gets its own JSON file: `YYYY-MM-DD.json`
- Store in app data directory (retrieved via Tauri command)
- Async file operations with proper error handling

### 5. Pomodoro Timer Issues
**Problem**: Tauri's `listen` API may not work reliably
**Solution**: Use JavaScript setTimeout/setInterval with custom modals for alerts

## Development Patterns

### Rust Backend Commands
```rust
#[tauri::command]
async fn command_name(param: String) -> Result<ReturnType, String> {
    // Always return Result<T, String> for proper error handling
    // Use tokio for async file operations
}
```

### Frontend API Calls
```javascript
try {
    const result = await window.invoke('command_name', { param: value });
} catch (error) {
    console.error('Command failed:', error);
    // Handle error appropriately
}
```

### DOM Element Management
```javascript
// Declare at top of file
const element = document.getElementById('element-id');

// Check existence before use
if (!element) {
    console.error('Element not found!');
    return;
}
```

### CSS Organization
- Use CSS custom properties for dynamic values
- Prefer rem/em units over px for scalability  
- Group related styles together
- Use transitions for smooth user experience

## Debugging Tips

### Console Logging
Add comprehensive logging for:
- Element existence checks
- API call results
- Event handler execution
- State changes

### Common Debug Points
1. Check if Tauri API is available: `window.__TAURI__`
2. Verify DOM elements exist before adding listeners
3. Monitor CSS custom property updates in DevTools
4. Check file permissions for data directory access

### DevTools Access
- Right-click in app → "Inspect" 
- Or press F12
- Enable in `tauri.conf.json`: `"devtools": true`

## Architecture Decisions

### Why No Build Process
- Simple static HTML/CSS/JS is sufficient
- Reduces complexity and build dependencies
- Faster development iteration
- Easier debugging

### File Storage Strategy
- JSON files per day for data separation
- Human-readable format for debugging
- Easy backup and data portability

### Custom Modals Over Native Dialogs
- Consistent cross-platform appearance
- Full control over styling and behavior
- Works within Tauri's security constraints

## Future Development Notes

### Adding New Features
1. Add Rust command if backend logic needed
2. Update frontend to call new commands
3. Test error handling scenarios
4. Update this documentation

### Performance Considerations
- File I/O is async - don't block UI
- Batch operations when possible
- Consider caching for frequently accessed data

### Security Notes
- CSP policy allows inline scripts (required for simple setup)
- File operations are sandboxed to app data directory
- No network requests currently - would need CSP updates

## Troubleshooting Checklist

When something breaks:
1. ✅ Check browser console for JavaScript errors
2. ✅ Verify DOM elements exist (not null)
3. ✅ Confirm Tauri API is available (`window.invoke`)
4. ✅ Check Rust terminal output for backend errors
5. ✅ Verify file paths and permissions
6. ✅ Test in development vs production build
7. ✅ Check CSP policy if adding new features

## Versioning Strategy

### Current Version: 1.0.0
- Uses Semantic Versioning (SemVer): MAJOR.MINOR.PATCH
- Version must be updated in 3 places:
  1. `src-tauri/Cargo.toml`
  2. `src-tauri/tauri.conf.json` 
  3. `ui/index.html` (version display)

### Release Process
1. Update version numbers in all 3 files
2. Document changes in `CHANGELOG.md`
3. Test all functionality thoroughly
4. Create git tag: `git tag v1.0.0`
5. Build release: `cargo tauri build`

### Version Guidelines
- **MAJOR**: Breaking changes (data format, core functionality)
- **MINOR**: New features (export, themes, new todo types)
- **PATCH**: Bug fixes (UI issues, performance improvements)

## Key Learnings Summary

1. **Tauri API Access**: Requires `withGlobalTauri: true` configuration
2. **Native Dialogs**: Don't work - use custom HTML modals instead
3. **Font Scaling**: Must use root-level CSS scaling with rem units
4. **Event Listeners**: Declare DOM elements at top, set up after DOM ready
5. **File Storage**: Use app data directory with proper async handling
6. **Development**: Use `cargo tauri dev` from src-tauri directory
7. **Debugging**: DevTools + comprehensive console logging essential
8. **Error Handling**: Always use Result<T, String> in Rust commands
9. **Versioning**: Keep version sync across Cargo.toml, tauri.conf.json, and UI

This app demonstrates a complete desktop application with proper error handling, user experience considerations, accessibility features, and professional versioning.
# Copilot Instructions for Todo Notes Tracker

## Project Overview
This is a bullet journal style todo app built with Tauri v2.8.4, featuring:
- Daily todo management with bullet journal symbols
- Date navigation (previous/next day, jump to today)
- Notes section with toggle functionality
- Pomodoro timer with custom alerts
- Text zoom accessibility features
- JSON file storage in app data directory

## Tech Stack
- **Backend**: Rust with Tauri v2.8.4, tokio async runtime
- **Frontend**: Vanilla HTML/CSS/JavaScript (no build process)
- **Storage**: JSON files in app data directory
- **Dependencies**: chrono, uuid, serde_json

## Critical Tauri Configuration

### API Access Fix
**Problem**: `window.invoke` and other Tauri APIs not available in frontend
**Solution**: Add `withGlobalTauri: true` to `tauri.conf.json`:
```json
{
  "app": {
    "withGlobalTauri": true,
    "security": {
      "csp": "default-src 'self'; script-src 'self' 'unsafe-inline'"
    }
  }
}
```

### Running the App
- **Correct**: `cd src-tauri && cargo tauri dev`
- **Wrong**: `npm run tauri dev` (no package.json needed for static frontend)

## Common Issues and Solutions

### 1. Native Dialogs Don't Work
**Problem**: `alert()`, `confirm()`, `prompt()` are blocked in Tauri webviews
**Solution**: Implement custom modal dialogs in HTML/CSS/JS

Example custom confirm dialog:
```javascript
function showConfirmDialog(message) {
    return new Promise((resolve) => {
        // Create modal HTML, handle user input, resolve promise
    });
}
```

### 2. Event Listeners Not Working
**Problem**: DOM elements not found when setting up event listeners
**Solution**: Ensure proper initialization order:
1. Wait for DOM ready
2. Initialize Tauri API
3. Declare all DOM element variables at top of file
4. Set up event listeners after DOM is ready

### 3. Zoom/Font Scaling Implementation
**Problem**: CSS custom properties not affecting all text
**Solution**: Scale at root level with rem units:
```css
:root {
    --zoom-scale: 1.0;
}
html {
    font-size: calc(16px * var(--zoom-scale));
}
/* Use rem units for scalable elements */
body { font-size: 0.875rem; }
```

**Avoid**: Fixed px units that won't scale
**Convert**: `font-size: 14px` → `font-size: 0.875rem`

### 4. File I/O and Data Persistence
**Structure**: 
- Each day gets its own JSON file: `YYYY-MM-DD.json`
- Store in app data directory (retrieved via Tauri command)
- Async file operations with proper error handling

### 5. Pomodoro Timer Issues
**Problem**: Tauri's `listen` API may not work reliably
**Solution**: Use JavaScript setTimeout/setInterval with custom modals for alerts

## Development Patterns

### Rust Backend Commands
```rust
#[tauri::command]
async fn command_name(param: String) -> Result<ReturnType, String> {
    // Always return Result<T, String> for proper error handling
    // Use tokio for async file operations
}
```

### Frontend API Calls
```javascript
try {
    const result = await window.invoke('command_name', { param: value });
} catch (error) {
    console.error('Command failed:', error);
    // Handle error appropriately
}
```

### DOM Element Management
```javascript
// Declare at top of file
const element = document.getElementById('element-id');

// Check existence before use
if (!element) {
    console.error('Element not found!');
    return;
}
```

### CSS Organization
- Use CSS custom properties for dynamic values
- Prefer rem/em units over px for scalability  
- Group related styles together
- Use transitions for smooth user experience

## Debugging Tips

### Console Logging
Add comprehensive logging for:
- Element existence checks
- API call results
- Event handler execution
- State changes

### Common Debug Points
1. Check if Tauri API is available: `window.__TAURI__`
2. Verify DOM elements exist before adding listeners
3. Monitor CSS custom property updates in DevTools
4. Check file permissions for data directory access

### DevTools Access
- Right-click in app → "Inspect" 
- Or press F12
- Enable in `tauri.conf.json`: `"devtools": true`

## Architecture Decisions

### Why No Build Process
- Simple static HTML/CSS/JS is sufficient
- Reduces complexity and build dependencies
- Faster development iteration
- Easier debugging

### File Storage Strategy
- JSON files per day for data separation
- Human-readable format for debugging
- Easy backup and data portability

### Custom Modals Over Native Dialogs
- Consistent cross-platform appearance
- Full control over styling and behavior
- Works within Tauri's security constraints

## Future Development Notes

### Adding New Features
1. Add Rust command if backend logic needed
2. Update frontend to call new commands
3. Test error handling scenarios
4. Update this documentation

### Performance Considerations
- File I/O is async - don't block UI
- Batch operations when possible
- Consider caching for frequently accessed data

### Security Notes
- CSP policy allows inline scripts (required for simple setup)
- File operations are sandboxed to app data directory
- No network requests currently - would need CSP updates

## Troubleshooting Checklist

When something breaks:
1. ✅ Check browser console for JavaScript errors
2. ✅ Verify DOM elements exist (not null)
3. ✅ Confirm Tauri API is available (`window.invoke`)
4. ✅ Check Rust terminal output for backend errors
5. ✅ Verify file paths and permissions
6. ✅ Test in development vs production build
7. ✅ Check CSP policy if adding new features
8. ✅ **Run ALL tests**: `./run-tests.sh` - often reveals the real issue
9. ✅ **Check test failures**: Failed tests pinpoint exact problems
10. ✅ **Test your changes**: Add tests for new code to prevent regressions

## Versioning Strategy

### Current Version: 1.0.0
- Uses Semantic Versioning (SemVer): MAJOR.MINOR.PATCH
- Version must be updated in 3 places:
  1. `src-tauri/Cargo.toml`
  2. `src-tauri/tauri.conf.json` 
  3. `ui/index.html` (version display)

### Release Process
1. Update version numbers in all 3 files
2. Document changes in `CHANGELOG.md`
3. Test all functionality thoroughly
4. Create git tag: `git tag v1.0.0`
5. Build release: `cargo tauri build`

### Version Guidelines
- **MAJOR**: Breaking changes (data format, core functionality)
- **MINOR**: New features (export, themes, new todo types)
- **PATCH**: Bug fixes (UI issues, performance improvements)

## Key Learnings Summary

1. **Tauri API Access**: Requires `withGlobalTauri: true` configuration
2. **Native Dialogs**: Don't work - use custom HTML modals instead
3. **Font Scaling**: Must use root-level CSS scaling with rem units
4. **Event Listeners**: Declare DOM elements at top, set up after DOM ready
5. **File Storage**: Use app data directory with proper async handling
6. **Development**: Use `cargo tauri dev` from src-tauri directory
7. **Debugging**: DevTools + comprehensive console logging essential
8. **Error Handling**: Always use Result<T, String> in Rust commands
9. **Versioning**: Keep version sync across Cargo.toml, tauri.conf.json, and UI
10. **Testing**: Comprehensive unit tests are mandatory for all code changes

## Testing Requirements ⚠️ MANDATORY

**All code changes MUST include comprehensive unit tests. No exceptions.**

### Testing Standards
- **Backend (Rust)**: Unit tests required for ALL public functions and commands
- **Frontend (JavaScript)**: Unit tests required for ALL functions and user interactions
- **Integration**: End-to-end tests for complete workflows
- **Error Handling**: Tests for ALL error scenarios and edge cases

### Before Any Change is Considered Complete:
1. ✅ **ALL existing tests must pass** - `./run-tests.sh` returns success
2. ✅ **New functionality must have corresponding tests** covering:
   - Normal operation (happy path)
   - Error conditions and edge cases
   - Boundary conditions (empty data, large data, special characters)
   - Integration with existing features
3. ✅ **Test coverage must be maintained** - no decrease in coverage
4. ✅ **Manual testing must be performed** via `ui/test-runner.html`

### Test Files and Commands
- **Backend Tests**: Located in `src-tauri/src/main.rs` (test module)
- **Frontend Tests**: Located in `ui/test-*.js` files
- **Run All Tests**: Execute `./run-tests.sh` from project root
- **Manual Frontend Tests**: Open `ui/test-runner.html` in the Tauri app

### Testing Documentation
- Comprehensive testing guide available in `TESTING.md`
- Test infrastructure includes mocks, utilities, and visual test runner
- CI/CD pipeline automatically runs tests on all commits

### Examples of Required Test Coverage
```rust
// Rust: Every command needs tests like this
#[tokio::test]
async fn test_command_name() {
    let result = command_name(test_input).await;
    assert!(result.is_ok());
    // Test error cases too
    let error_result = command_name(invalid_input).await;
    assert!(error_result.is_err());
}
```

```javascript
// JavaScript: Every function needs tests like this
test('function should handle normal input', async () => {
    const result = await functionName('valid input');
    assert.equal(result, expected_output);
});

test('function should handle error cases', async () => {
    await assert.throwsAsync(async () => {
        await functionName('invalid input');
    });
});
```

### Test-First Development (Strongly Recommended)
1. Write tests for new functionality BEFORE implementing
2. Implement just enough code to make tests pass
3. Refactor while keeping tests green
4. Add edge case tests and make them pass

**REMEMBER: Tests are not optional. They are a core part of the codebase that ensures reliability, maintainability, and confidence in changes.**

This app demonstrates a complete desktop application with proper error handling, user experience considerations, accessibility features, professional versioning, and most importantly, comprehensive test coverage that validates all functionality.
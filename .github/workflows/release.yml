name: 'Release'

on:
  workflow_run:
    workflows: ["Tests"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release build for current version'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # Job 1: Determine if a release is needed and calculate version
  version:
    runs-on: ubuntu-latest
    # Only run if tests passed OR if manually triggered
    if: |
      github.event_name == 'workflow_dispatch' || 
      github.event.workflow_run.conclusion == 'success'
    outputs:
      should-release: ${{ steps.version-check.outputs.should-release }}
      new-version: ${{ steps.version-check.outputs.new-version }}
      version-type: ${{ steps.version-check.outputs.version-type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if release needed
        id: version-check
        run: |
          # Check if this is a forced release
          if [ "${{ github.event.inputs.force_release }}" = "true" ]; then
            echo "Force release requested"
            CURRENT_VERSION=$(grep '"version"' src-tauri/tauri.conf.json | head -1 | sed 's/.*"version": "\(.*\)".*/\1/')
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "new-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            echo "version-type=manual" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Get current version from tauri.conf.json
          CURRENT_VERSION=$(grep '"version"' src-tauri/tauri.conf.json | head -1 | sed 's/.*"version": "\(.*\)".*/\1/')
          echo "Current version: $CURRENT_VERSION"
          
          # Remove 'v' prefix from tag for comparison
          TAG_VERSION=${LATEST_TAG#v}
          
          # Check if version has changed
          if [ "$CURRENT_VERSION" != "$TAG_VERSION" ]; then
            echo "Version changed from $TAG_VERSION to $CURRENT_VERSION"
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "new-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
            
            # Determine version type (major, minor, patch)
            IFS='.' read -ra CURRENT <<< "$CURRENT_VERSION"
            IFS='.' read -ra PREVIOUS <<< "$TAG_VERSION"
            
            if [ "${CURRENT[0]}" -gt "${PREVIOUS[0]}" ]; then
              echo "version-type=major" >> $GITHUB_OUTPUT
            elif [ "${CURRENT[1]}" -gt "${PREVIOUS[1]}" ]; then
              echo "version-type=minor" >> $GITHUB_OUTPUT
            else
              echo "version-type=patch" >> $GITHUB_OUTPUT
            fi
          else
            echo "No version change detected"
            echo "should-release=false" >> $GITHUB_OUTPUT
          fi

  # Job 2: Build Tauri bundles for macOS and Windows
  build-bundles-native:
    needs: version
    if: needs.version.outputs.should-release == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            target: x86_64-apple-darwin
          - platform: macos-latest
            target: aarch64-apple-darwin
          - platform: windows-latest
            target: x86_64-pc-windows-msvc

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "src-tauri -> target"
          shared-key: "release-${{ matrix.target }}"
          cache-on-failure: true

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2.0" --locked

      - name: Build Tauri bundles
        run: |
          cd src-tauri
          cargo tauri build --target ${{ matrix.target }}

      - name: Prepare bundle artifacts (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          mkdir -p artifacts
          # Copy DMG installer
          find "src-tauri/target/${{ matrix.target }}/release/bundle/dmg" -name "*.dmg" -exec cp {} artifacts/ \; 2>/dev/null || true
          # Copy app bundle
          find "src-tauri/target/${{ matrix.target }}/release/bundle/macos" -name "*.app" -exec cp -r {} artifacts/ \; 2>/dev/null || true
          echo "Generated artifacts:"
          ls -la artifacts/

      - name: Prepare bundle artifacts (Windows)
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          mkdir artifacts
          # Copy MSI installer
          if (Test-Path "src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi") {
            Copy-Item "src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi" artifacts/
          }
          # Copy NSIS installer if present
          if (Test-Path "src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe") {
            Copy-Item "src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe" artifacts/
          }
          Write-Output "Generated artifacts:"
          Get-ChildItem artifacts/

      - name: Upload bundle artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bundle-${{ matrix.target }}
          path: artifacts/*
          retention-days: 30

  # Job 3: Build Tauri bundles for Linux (using container for GLIBC compatibility)
  build-bundles-linux:
    needs: version
    if: needs.version.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    container:
      image: ivangabriele/tauri:debian-bookworm-22
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: "src-tauri -> target"
          shared-key: "release-${{ matrix.target }}"
          cache-on-failure: true

      - name: Install Tauri CLI
        run: cargo install tauri-cli --version "^2.0" --locked

      - name: Build Tauri bundles
        run: |
          cd src-tauri
          # Only build DEB package in container (AppImage creation fails due to FUSE requirements)
          cargo tauri build --target ${{ matrix.target }} --bundles deb

      - name: Prepare bundle artifacts (Linux)
        run: |
          mkdir -p artifacts
          # Copy deb package (AppImage skipped in container due to FUSE limitations)
          find "src-tauri/target/${{ matrix.target }}/release/bundle/deb" -name "*.deb" -exec cp {} artifacts/ \; 2>/dev/null || true
          echo "Generated artifacts:"
          ls -la artifacts/

      - name: Upload bundle artifacts
        uses: actions/upload-artifact@v4
        with:
          name: bundle-${{ matrix.target }}
          path: artifacts/*
          retention-days: 30

  # Job 4: Create GitHub release with all artifacts
  create-release:
    needs: [version, build-bundles-native, build-bundles-linux]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Generate release notes
        id: release-notes
        run: |
          # Get the tag we're about to create (but haven't yet)
          NEW_TAG="v${{ needs.version.outputs.new-version }}"
          
          # Get the previous tag (excluding the new one if it exists)
          # Use --exclude to ignore the new tag pattern
          LATEST_TAG=$(git describe --tags --abbrev=0 --exclude="$NEW_TAG" 2>/dev/null || echo "")
          
          echo "Previous tag: $LATEST_TAG"
          echo "New tag: $NEW_TAG"
          
          # Get all commits since last tag
          if [ -n "$LATEST_TAG" ]; then
            echo "Getting commits from $LATEST_TAG to HEAD..."
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:"- %s" --no-merges)
            COMMIT_COUNT=$(git rev-list ${LATEST_TAG}..HEAD --count --no-merges)
          else
            echo "No previous tag found, getting all commits..."
            COMMITS=$(git log --oneline --pretty=format:"- %s" --no-merges | head -20)
            COMMIT_COUNT=$(git rev-list HEAD --count --no-merges)
          fi
          
          echo "Found $COMMIT_COUNT commits"
          
          # Group commits by type (feat, fix, chore, docs, etc.)
          FEATURES=$(echo "$COMMITS" | grep -i "^- feat" || echo "")
          FIXES=$(echo "$COMMITS" | grep -i "^- fix" || echo "")
          CHORES=$(echo "$COMMITS" | grep -i "^- chore" || echo "")
          DOCS=$(echo "$COMMITS" | grep -i "^- docs" || echo "")
          OTHER=$(echo "$COMMITS" | grep -iv "^- \(feat\|fix\|chore\|docs\)" || echo "")
          
          # Create release notes
          cat > release_notes.md << 'EOF'
          # Todo Notes Tracker v${{ needs.version.outputs.new-version }}
          
          A ${{ needs.version.outputs.version-type }} release with new features and improvements.
          
          ## What's Changed
          
          EOF
          
          # Add features section if any
          if [ -n "$FEATURES" ]; then
            echo "### âœ¨ New Features" >> release_notes.md
            echo "$FEATURES" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          # Add fixes section if any
          if [ -n "$FIXES" ]; then
            echo "### ðŸ› Bug Fixes" >> release_notes.md
            echo "$FIXES" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          # Add documentation section if any
          if [ -n "$DOCS" ]; then
            echo "### ðŸ“š Documentation" >> release_notes.md
            echo "$DOCS" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          # Add chores section if any
          if [ -n "$CHORES" ]; then
            echo "### ðŸ”§ Maintenance" >> release_notes.md
            echo "$CHORES" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          # Add other changes if any
          if [ -n "$OTHER" ]; then
            echo "### ðŸ”„ Other Changes" >> release_notes.md
            echo "$OTHER" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          # Add download and installation sections
          cat >> release_notes.md << 'EOF'
          
          ## Download
          Choose the appropriate package for your platform:
          
          - **macOS**: Download the \`.dmg\` file for your architecture
            - Apple Silicon (M1/M2/M3): `*_aarch64.dmg`
            - Intel: `*_x64.dmg`
          - **Windows**: Download the \`.msi\` installer or \`.exe\` setup file
          - **Linux**: Download the \`.deb\` package
          
          ## Installation
          
          ### macOS
          1. Download the appropriate DMG file for your Mac
          2. Open the DMG and drag Todo Notes Tracker to Applications
          3. Launch from Applications folder
          4. If macOS blocks it, go to System Preferences â†’ Security & Privacy â†’ Open Anyway
          
          ### Windows  
          1. Download the MSI installer or EXE setup file
          2. Run the installer and follow the prompts
          3. Launch from Start Menu or Desktop shortcut
          
          ### Linux
          1. Download the DEB package
          2. Install: \`sudo dpkg -i todo-notes-tracker*.deb\`
          3. Or double-click the file to install via Software Center
          4. Launch from Applications menu or run \`todo-notes-tracker\`
          
          ## Features
          - âœ… Daily todo management with bullet journal symbols
          - âœ… Edit todo items with double-click
          - âœ… Per-item notes for detailed task information
          - âœ… Calendar view with event planning
          - âœ… Notes section for daily thoughts
          - âœ… Pomodoro timer with notifications
          - âœ… Text zoom for accessibility
          - âœ… Dark mode support
          - âœ… Data persistence and cross-platform support
          - âœ… Resizable panels for customized workspace
          
          EOF
          
          # Add comparison link if we have a previous tag
          if [ -n "$LATEST_TAG" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$LATEST_TAG...v${{ needs.version.outputs.new-version }}" >> release_notes.md
          else
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/commits/v${{ needs.version.outputs.new-version }}" >> release_notes.md
          fi
          
          echo "Release notes generated successfully"
          cat release_notes.md

      - name: Create release tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if tag already exists locally and remotely
          TAG_NAME="v${{ needs.version.outputs.new-version }}"
          
          # Delete local tag if it exists
          git tag -d "$TAG_NAME" 2>/dev/null || true
          
          # Delete remote tag if it exists
          git push --delete origin "$TAG_NAME" 2>/dev/null || true
          
          # Create new tag
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: v${{ needs.version.outputs.new-version }}
          name: Todo Notes Tracker v${{ needs.version.outputs.new-version }}
          bodyFile: release_notes.md
          artifacts: "release-artifacts/**/*.dmg,release-artifacts/**/*.msi,release-artifacts/**/*.exe,release-artifacts/**/*.deb"
          token: ${{ secrets.GITHUB_TOKEN }}
          draft: false
          prerelease: false
          generateReleaseNotes: false